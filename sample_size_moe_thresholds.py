# -*- coding: utf-8 -*-
"""sample_size_moe_thresholds.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gvNKWD79QoGrd7xzljdXmW5x_ADd1F8T
"""

# ==========================================================
# Sample Size MOE Thresholds = 16 (Colab Ready)
# - Computes the MOE interval where rounded n == 16 (Cochran + FPC)
# - Shows lower bound, midpoint, upper bound
# - Uses "last 6-digit value before change" for display
# - Inline plot + auto-export PDF
# ==========================================================

import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.collections import PolyCollection
from matplotlib.ticker import FormatStrFormatter
from google.colab import files

# -------------------------------
# Parameters (edit if needed)
# -------------------------------
CL = 0.80
Z  = 1.28
p  = 0.50
N  = 20000
n_target = 16         # we’re targeting sample size 16
search_min = 0.12     # MOE search band (reasonable window)
search_max = 0.20

pdf_name = "MOE_Thresholds_for_n16.pdf"

# -------------------------------
# Core math
# -------------------------------
def n0_infinite(Z, p, e):
    return (Z**2 * p * (1 - p)) / (e**2)

def n_fpc(N, Z, p, e):
    n0 = n0_infinite(Z, p, e)
    return n0 / (1 + (n0 - 1) / N)

def round_half_up(x):
    return int(math.floor(x + 0.5))

# f(e) = rounded_n(e) - n_target
def f(e):
    return round_half_up(n_fpc(N, Z, p, e)) - n_target

# -------------------------------
# Find the e-interval where rounded n == n_target
# -------------------------------
def find_interval_for_n(n_target, e_lo, e_hi, steps=20000):
    """Coarse scan to find contiguous [a, b] where f(e) == 0."""
    es = np.linspace(e_lo, e_hi, steps)
    vals = np.array([f(e) for e in es])

    inside = (vals == 0)
    if not inside.any():
        return None, None

    idx = np.where(inside)[0]
    a = es[idx[0]]
    b = es[idx[-1]]
    return a, b

def refine_boundary(target_state, e_left, e_right, tol=1e-10, max_iter=80):
    """
    Refine boundary by binary search so that:
      - if target_state==0, we find an interior point where f(e)==0
      - otherwise we find the boundary where f changes value
    This helper expects e_left and e_right straddle a boundary.
    """
    fl = f(e_left)
    fr = f(e_right)
    for _ in range(max_iter):
        mid = (e_left + e_right) / 2
        fm  = f(mid)
        if target_state == 0:
            # drive to inside region
            if fm == 0:
                e_right = mid
                fr = fm
            else:
                e_left = mid
                fl = fm
        else:
            # drive to change point
            if fm == fr:
                e_right = mid
                fr = fm
            else:
                e_left  = mid
                fl = fm
        if abs(e_right - e_left) < tol:
            break
    return (e_left + e_right) / 2

def refine_interval(a0, b0, pad=5e-3, tol=1e-12):
    """
    Given a coarse interval [a0, b0] where f==0,
    push slightly outward, then refine left/right boundaries.
    """
    L = max(search_min, a0 - pad)
    R = min(search_max, b0 + pad)

    # Refine left boundary: find where it switches from !0 to 0
    # Scan leftwards a bit to ensure sign change
    l1, l2 = L, a0
    # Ensure f(l1) != 0 and f(l2) == 0 (if not, nudge)
    if f(l2) != 0:
        l2 = refine_boundary(0, l1, l2, tol=tol)
    left = refine_boundary(1, l1, l2, tol=tol)  # boundary point

    # Refine right boundary: find where it switches from 0 to !0
    r1, r2 = b0, R
    # Ensure f(r1) == 0 and f(r2) != 0 (if not, nudge)
    if f(r1) != 0:
        r1 = refine_boundary(0, r1, r2, tol=tol)
    right = refine_boundary(1, r1, r2, tol=tol)  # boundary point

    return left, right

# 1) Coarse interval
a_coarse, b_coarse = find_interval_for_n(n_target, search_min, search_max, steps=40001)
if a_coarse is None:
    raise RuntimeError("Could not find any MOE interval where rounded n equals 16. Adjust search_min/search_max.")

# 2) Refine to precise real-number bounds (true math bounds)
e_low_true, e_high_true = refine_interval(a_coarse, b_coarse)

# 3) Midpoint (for the “mid-point MOE” line)
e_mid = (e_low_true + e_high_true) / 2

# 4) Display bounds: “last 6-digit value before change”
#    - For the lower bound: smallest MOE that still yields n=16, to 6 decimals → ceil at 1e6
#    - For the upper bound: largest MOE that still yields n=16, to 6 decimals → floor at 1e6
e_low_display  = math.ceil(e_low_true  * 1_000_000) / 1_000_000
e_high_display = math.floor(e_high_true * 1_000_000) / 1_000_000

# Safety clamp to ensure they still map to n_target after rounding rules
if f(e_low_display) != 0:
    # step upward until it does or give up after a few micro-steps
    for _ in range(20):
        e_low_display += 1e-6
        if f(e_low_display) == 0:
            break

if f(e_high_display) != 0:
    for _ in range(20):
        e_high_display -= 1e-6
        if f(e_high_display) == 0:
            break

# -------------------------------
# Plot helper: gradient fill
# -------------------------------
def add_horizontal_gradient(ax, x0, x1, alpha=0.30, n=300):
    y0, y1 = ax.get_ylim()
    xs = np.linspace(x0, x1, n + 1)
    quads, colors = [], []
    for i in range(n):
        quads.append([(xs[i], y0), (xs[i+1], y0), (xs[i+1], y1), (xs[i], y1)])
        t = i / (n - 1) if n > 1 else 0.0
        colors.append((1.0 - t, 0.0, t, alpha))  # red -> blue
    pc = PolyCollection(quads, facecolors=colors, edgecolors='none', zorder=0.5)
    ax.add_collection(pc)

# -------------------------------
# Build visualization
# -------------------------------
fig, ax = plt.subplots(figsize=(9, 5))

# X-limits with a little padding around the true bounds
pad = 0.0015
ax.set_xlim(e_low_true - pad, e_high_true + pad)
ax.set_ylim(0, 1)  # simple strip chart

# Gradient between true bounds
add_horizontal_gradient(ax, e_low_true, e_high_true, alpha=0.30)

# Vertical decision lines
ax.axvline(e_low_display,  color='red',  linestyle='--', linewidth=1.5, label=f"Lower bound (to 6dp): {e_low_display:.6f}")
ax.axvline(e_mid,          color='black', linestyle='-',  linewidth=2.0,  label=f"Mid-point: {e_mid:.6f}")
ax.axvline(e_high_display, color='blue', linestyle='--',  linewidth=1.5, label=f"Upper bound (to 6dp): {e_high_display:.6f}")

# Labels, nudged away from lines
ax.text(e_low_display  - (pad*0.8), 0.90, f"{e_low_display:.6f}\n(last before n→17)",  color='red',
        ha='right', va='center', bbox=dict(facecolor='white', edgecolor='red'))
ax.text(e_high_display + (pad*0.8), 0.90, f"{e_high_display:.6f}\n(last before n→15)", color='blue',
        ha='left', va='center', bbox=dict(facecolor='white', edgecolor='blue'))
ax.text(e_mid, 0.08, f"Mid-point MOE\n{e_mid:.6f}", color='black',
        ha='center', va='center', bbox=dict(facecolor='white', edgecolor='black'))

# Cosmetics
ax.set_title("MOE Thresholds Where Rounded Sample Size = 16", fontsize=13, fontweight='bold', pad=8)
ax.set_xlabel("Margin of Error (e)")
ax.get_yaxis().set_visible(False)
ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15), ncol=3, fontsize=9)
ax.xaxis.set_major_formatter(FormatStrFormatter('%.6f'))

plt.tight_layout()
plt.show()

# -------------------------------
# Export PDF and auto-download
# -------------------------------
fig.savefig(pdf_name, bbox_inches='tight', dpi=300)
files.download(pdf_name)

"""# V2"""

